import botocore.exceptions
import datetime
import logging
import urllib.request

ATTACHED = 'attached'

VOLUME_AVAILABLE = 'volume_available'

VOLUME_IN_USE = 'volume_in_use'

ATTACHMENT_STATUS = 'attachment.status'

DEFAULT_TYPE = 'gp2'

DEFAULT_SIZE = 20

VOLUMES = 'Volumes'

VALUE = 'Value'

KEY = 'Key'

VOLUME = 'volume'

RESOURCE_TYPE = 'ResourceType'

TAGS = 'Tags'

VALUES = 'Values'

NAME = 'Name'

ADDRESSES = 'Addresses'

ALLOCATION_ID = 'AllocationId'

VOLUME_ID = 'VolumeId'

INSTANCE_ID = 'InstanceId'

DEFAULT_MOUNT_POINT = '/dev/sdf'

RESERVATIONS = 'Reservations'

INSTANCES = 'Instances'

PLACEMENT = 'Placement'

AVAILABILITY_ZONE = 'AvailabilityZone'

VOLUME_ID = 'VolumeId'

DATE_TIME_FORMAT = '%Y-%m-%d_%H:%M:%S'

NAME = 'Name'

SPOT_RECOVERY_TRACKER = 'spot-recovery-tracker'

VALUE = 'Value'

LOG = logging.getLogger()


class VolumeNotFoundException(Exception):
    pass


class Ec2Manager(object):

    def __init__(self, session, dry_run=True):
        self.client = session.client('ec2')
        self.resource = session.resource('ec2')
        self.dry_run = dry_run

    '''
        Finds the AWS instance by the given instance_id.
    '''
    def find_instance_by_id(self, instance_id):
        try:
            instances_resp = self.client.describe_instances(InstanceIds=[
                instance_id,
            ])
            instance = self.resource.Instance(instances_resp[RESERVATIONS][0][INSTANCES][0][INSTANCE_ID])
            LOG.info('Found instance {}'.format(instance.id))
            return instance
        except botocore.exceptions.ClientError as ex:
            raise Exception('Couldn''t find region of instanceId {}. Please check if you have the right permission to'
                            'list describe_instances and that the instance still exists.'.format(instance_id), ex)

    '''
        Mount the given volume to the given instance_id.
    '''
    def mount_volume(self, volume, instance_id, mount_point=DEFAULT_MOUNT_POINT):
        self.client.get_waiter(VOLUME_AVAILABLE).wait(VolumeIds=[volume.id])
        volume.attach_to_instance(
            Device=mount_point,
            InstanceId=instance_id,
            DryRun=self.dry_run
        )
        self.client.get_waiter(VOLUME_IN_USE).wait(
            Filters=[
                {
                    NAME: ATTACHMENT_STATUS,
                    VALUES: [
                        ATTACHED,
                    ]
                },
            ],
            VolumeIds=[volume.id]
        )


    '''
        Finds a volume by the given volume_id.
    '''
    def find_volume_by_id(self, volume_id):
        volumes_resp = self.client.describe_volumes(
            VolumeIds=[
                volume_id,
            ],
            DryRun=self.dry_run,
            MaxResults=1,
        )
        if not volumes_resp[VOLUMES]:
            raise VolumeNotFoundException('No volumes were found with id {}'.format(volume_id))

        volume = self.resource.Volume(volumes_resp[VOLUMES][0][VOLUME_ID])
        LOG.info('Found volume {}'.format(volume.id))
        return volume

    '''
        Find the latest created volume by the given service tag (should be the volume that was being used when the spot
        instance died).
    '''
    def find_latest_volume_by_tag(self, service_tag):
        volumes_resp = self.client.describe_volumes(Filters=[
            {
                'Name': 'tag:' + SPOT_RECOVERY_TRACKER,
                'Values': [
                    service_tag
                ]
            },
        ])
        if not volumes_resp[VOLUMES]:
            raise VolumeNotFoundException('No volumes were found with tag {}'.format(service_tag))
        volumes = sorted(volumes_resp[VOLUMES], key=lambda v: v['CreateTime'])
        volume = self.resource.Volume(volumes[-1][VOLUME_ID])
        LOG.info('Found volume {}'.format(volume.id))
        return volume

    '''
        Clones the given volume in the destination AZ and tags it with 
    '''
    def clone_volume(self, src_volume, dest_az, delete=False):
        snapshot_tag = next(tag[VALUE] for tag in src_volume.tags if tag[KEY] == SPOT_RECOVERY_TRACKER)
        snapshot_name = snapshot_tag + '-' + datetime.datetime.utcnow().strftime(DATE_TIME_FORMAT)
        snapshot = src_volume.create_snapshot(
            Description=(snapshot_name + ' generated by ebs-spot-recovery'),
            TagSpecifications=[
                {
                    RESOURCE_TYPE: 'snapshot',
                    TAGS: [
                        {
                            KEY: NAME,
                            VALUE: snapshot_name
                        },
                        {
                            KEY: SPOT_RECOVERY_TRACKER,
                            VALUE: snapshot_tag
                        },
                    ]
                },
            ],
            DryRun=self.dry_run
        )
        snapshot.wait_until_completed()

        volume_resp = self.client.create_volume(
            AvailabilityZone=dest_az,
            SnapshotId=snapshot.snapshot_id,
            VolumeType='gp2',
            DryRun=self.dry_run,
            TagSpecifications=[
                {
                    RESOURCE_TYPE: VOLUME,
                    TAGS: [
                        {
                            KEY: SPOT_RECOVERY_TRACKER,
                            VALUE: snapshot_tag
                        },
                    ]
                },
            ]
        )

        if delete:
            LOG.info('Going to delete original volume {}'.format(src_volume.id))
            src_volume.delete(DryRun=self.dry_run)

        return self.resource.Volume(volume_resp[VOLUME_ID])

    '''
        Finds and returns the running AWS instance.
    '''
    def find_running_instance(self):
        instance_id = urllib.request.urlopen('http://169.254.169.254/latest/meta-data/instance-id').read().decode()
        instance = self.resource.Instance(instance_id)
        LOG.info('Found running instance {}'.format(instance.id))
        return instance

    '''
        Attachs the given EIP to the given instance.
    '''
    def attach_eip(self, eip, instance):
        self.client.associate_address(
            AllocationId=eip,
            InstanceId=instance.id
        )

    '''
        Finds an EIP, if it does not exist creates and tags a new one.
    '''
    def find_or_create_eipalloc(self, service):
        eip_resp = self.client.describe_addresses(
            Filters=[
                {
                    NAME: 'tag:' + SPOT_RECOVERY_TRACKER,
                    VALUES: [
                        service,
                    ]
                },
            ],
            DryRun=self.dry_run
        )
        if eip_resp[ADDRESSES]:
            eipalloc = eip_resp[ADDRESSES][0]['AllocationId']
            LOG.info('Found eip {} using {} tag'.format(eipalloc, service))
            return eipalloc
        else:
            return self.create_eip(service)

    '''
        Allocates an EIP and tags it with service tag.
    '''
    def create_eip(self, service):
        eipalloc_resp = self.client.allocate_address(
            Domain='vpc',
            DryRun=self.dry_run
        )
        LOG.info(eipalloc_resp)
        tag_resp = self.client.create_tags(
            Resources=[
                eipalloc_resp[ALLOCATION_ID],
            ],
            Tags=[
                {
                    'Key': SPOT_RECOVERY_TRACKER,
                    'Value': service,
                },
            ],
        )
        LOG.info(tag_resp)
        return eipalloc_resp[ALLOCATION_ID]

    '''
        Finds a volume based on the given service tag, if it does not exist creates and tags a new one in the given AZ.
    '''
    def find_or_create_volume(self, service, instance_az):
        try:
            return self.find_latest_volume_by_tag(service)
        except VolumeNotFoundException:
            return self.create_volume(service, instance_az)

    '''
        Creates a volume in the given instance_az, tags it with service value and returns the created volume.
    '''
    def create_volume(self, service, instance_az):
        response = self.client.create_volume(
            AvailabilityZone=instance_az,
            Size=DEFAULT_SIZE,
            VolumeType=DEFAULT_TYPE,
            DryRun=self.dry_run,
            TagSpecifications=[
                {
                    RESOURCE_TYPE: VOLUME,
                    TAGS: [
                        {
                            KEY: SPOT_RECOVERY_TRACKER,
                            VALUE: service
                        },
                    ]
                },
            ]
        )
        return self.resource.Volume(response[VOLUME_ID])
